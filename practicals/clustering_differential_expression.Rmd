```{r}
library(Seurat)
seurat2obj = CreateSeuratObject(raw.data=myCountMatrixSparse)
```

###  examine contents of seurat2obj
```{r}
str(seurat2obj)
```

```{r}
VlnPlot(object = seurat2obj, features.plot = c("nGene"), group.by = c('orig.ident'))
```

Can add metadata about cells: 

```{r}
# let's just recompute percent mito again based on our filtered matrix:
mito.genes <- grep(pattern = "^mt-", x = rownames(x = seurat2obj@raw.data), ignore.case = TRUE, value = TRUE)
percent.mito <- Matrix::colSums(seurat2obj@raw.data[mito.genes, ]) /
                                        Matrix::colSums(seurat2obj@raw.data)

# AddMetaData adds columns to object@data.info, and is a great place to stash QC stats
seurat2obj <- AddMetaData(object = seurat2obj, 
                          metadata = percent.mito, 
                          col.name = "percent.mito")

VlnPlot(object = seurat2obj, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
```

### Normalizing the data

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method "LogNormalize" that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. 


```{r normalize}
seurat2obj <- NormalizeData(object = seurat2obj, 
                            normalization.method = "LogNormalize", 
                            scale.factor = 1e4)
```

### Detection of variable genes across the single cells

Seurat calculates highly variable genes and focuses on these for downstream analysis. **`FindVariableGenes`** calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. This function is unchanged from (Macosko *et al*.), but new methods for variable gene expression identification are coming soon. We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters here identify ~2,000 variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules.

```{r var_genes}
seurat2obj <- FindVariableGenes(object = seurat2obj, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.2, x.high.cutoff = 8, y.cutoff = 1.0, num.bin=20)  # if this fails, experiment with the num.bin setting
```

```{r len_var_genes}
length(x = seurat2obj@var.genes)
```

```{r pca_pre_regress}
seurat2obj <- ScaleData(object = seurat2obj)
seurat2obj <- RunPCA(object = seurat2obj, pc.genes = seurat2obj@var.genes, do.print = TRUE, pcs.print = 1:2, genes.print = 5, pcs.compute = 40, maxit = 500, weight.by.var = FALSE)
PCAPlot(object = seurat2obj, dim.1 = 1, dim.2 = 2)
```

```{r}
FeaturePlot(seurat2obj, dim.1=1, dim.2=2, reduction.use='pca', features.plot=c('nGene'))
```

```{r saveobject}
save(seurat2obj, file = "seurat2obj-pre_batch_correct.Robj")
```

How many dimensions are there really?

```{r}
PCElbowPlot(object = seurat2obj)
```

```{r tsne}
seurat2obj <- RunTSNE(object = seurat2obj, dims.use = 1:10, do.fast = TRUE)
TSNEPlot(object = seurat2obj)
```

  ##############################################################
  ## Standard regressing out the nGene and percent.mito effects:
  
  # regress out the nGene effects
  seurat2obj <- ScaleData(object = seurat2obj, vars.to.regress = c("nGene", "percent.mito"))
  
  # rerun PCA on the regressed-out, 'cleaner' data
  seurat2obj <- RunPCA(object = seurat2obj, pc.genes = seurat2obj@var.genes, 
                       do.print = FALSE, pcs.compute = 40, weight.by.var = FALSE)
  
  # redo PCA and tSNE
  seurat2obj <- RunTSNE(object = seurat2obj, 
                        dims.use = 1:10, # pca dimensions to use
                        seed.use = 12345, # random seed, layout will differ on diff settings
                        do.fast = TRUE) # runs Barnes-hut t-SNE
  TSNEPlot(object = seurat2obj)
  
  # plot pca according to number of genes
  FeaturePlot(seurat2obj, dim.1=1, dim.2=2, reduction.use='tsne', 
              features.plot=c('nGene', 'percent.mito'))

## Cluster the cells

>Note, most text in this section is lifted verbatim from the official Seurat2 tutorial. Modifications to code and/or text aim to make it generic for use in just about any target data set.

Seurat now includes a graph-based clustering approach compared to (Macosko *et al*.). Importantly, the *distance metric* which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partioning the cellular distance matrix into clusters has dramatically improved. Our approach was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [[SNN-Cliq, Xu and Su, Bioinformatics, 2015]](http://bioinformatics.oxfordjournals.org/content/early/2015/02/10/bioinformatics.btv088.abstract) and CyTOF data [[PhenoGraph, Levine *et al*., Cell, 2015]](http://www.ncbi.nlm.nih.gov/pubmed/26095251). Briefly, these methods embed cells in a graph structure - for example a K-nearest neighbor (KNN) graph, with edges drawn between cells with similar gene expression patterns, and then attempt to partition this graph into highly interconnected 'quasi-cliques' or 'communities'. As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard distance). To cluster the cells, we apply modularity optimization techniques [[SLM, Blondel *et al*., Journal of Statistical Mechanics]](http://dx.doi.org/10.1088/1742-5468/2008/10/P10008), to iteratively group cells together, with the goal of optimizing the standard modularity function.

The `FindClusters` function implements the procedure, and contains a resolution parameter that sets the 'granularity' of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.6-1.2 typically returns good results for single cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters are saved in the `object@ident` slot.

```{r cluster}
## - Find clusters ##

# save.SNN = T saves the SNN so that the clustering algorithm 
#           can be rerun using the same graph
# but with a different resolution value (see docs for full details)
seurat2obj <- FindClusters(object = seurat2obj, reduction.type = "pca", 
                           dims.use = 1:10, resolution = 0.8, 
                           print.output = 0, save.SNN = TRUE)

# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = seurat2obj, do.label=T)
```

You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.
```{r}
save(seurat2obj, file = "seurat2obj-post_batch_correct.Robj")
```

## Quality controling clusters

It is important to understand what is driving the clusters you are observing. This helps you to understand if you are looking at biological or technical effects. One of the easiest ways to do this is to plot technical metrics (like complexity, percent mictochondrial reads, or processing batches).

```{r}
# Plot QC
FeaturePlot(object = seurat2obj, features.plot = c(), cols.use = c("grey", "blue"), reduction.use = "tsne")
```

```{r}
# Plotting a prior known genes
FeaturePlot(object = seurat2obj, features.plot = c(), cols.use = c("grey", "blue"), reduction.use = "tsne")
```

# Assigning identity to clusters
current.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7)
new.cluster.ids <- c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", 
    "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")
pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
TSNEPlot(object = pbmc, do.label = TRUE, pt.size = 0.5)

## Subclustering

```{r}
MIN_LOGFOLD_CHANGE = 1 # set to minimum required average log fold change in gene expression.
MIN_PCT_CELLS_EXPR_GENE = 0.1  # minimum percent of cells that must express gene in either clstr.


all.markers = FindAllMarkers(seurat2obj,
                             min.pct = MIN_PCT_CELLS_EXPR_GENE,
                             thresh.use = MIN_LOGFOLD_CHANGE,
                             only.pos = TRUE,
                             test.use="bimod") # likelihood ratio test
```

```{r}
# sort all the markers by p-value
all.markers.sortedByPval = all.markers[order(all.markers$p_val),]

# take a look at the top most significant markers
head(all.markers.sortedByPval)
```

# make a heatmap showing the top 10 markers

```{r}
top10 <- all.markers.sortedByPval %>%  group_by(cluster)  %>% do(head(., n=10))
DoHeatmap(object = seurat2obj, genes.use = top10$gene, slim.col.label = TRUE, remove.key = TRUE)
```

```{r}
# examine the top 4 markers in the context of the tSNE plots:
FeaturePlot(seurat2obj, features.plot = all.markers.sortedByPval$gene[1:4])
```
### Get genes uniquely DE in each cluster:
```{r}
genes_uniquely_DE = all.markers.sortedByPval %>% dplyr::filter(avg_diff > MIN_LOGFOLD_CHANGE) %>% group_by(gene) %>%  summarize(n=n()) %>%  filter(n==1)

genes_uniquely_DE.markers.sortedByPval =
  all.markers.sortedByPval[all.markers.sortedByPval$gene
                           %in% genes_uniquely_DE$gene,]

top_marker_each = genes_uniquely_DE.markers.sortedByPval %>%
      dplyr::filter(avg_diff >= MIN_LOGFOLD_CHANGE) %>%
      dplyr::group_by(cluster) %>%
      do(head(., n=1))  # set to higher value to get that number of top markers each clst.
print(top_marker_each)
```
```{r}
for (gene in top_marker_each$gene) {
  FeaturePlot(seurat2obj, features.plot = gene)
}

```

### Other ways to explore marker genes:
Violin plots - examine distribution of gene expression across clustered cells.

```{r}
for (i in 1:length(top_marker_each$gene)) {
  print(VlnPlot(seurat2obj, features.plot = top_marker_each$gene[i]))
}
```

The DotPlot: a concise way of exploring percent of cells expressing a gene and the gene expression intensity.

```{r}
DotPlot(seurat2obj, genes.plot=unique(top_marker_each$gene))
```
